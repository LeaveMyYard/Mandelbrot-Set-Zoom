#include "pch.h"
#include <cmath>
#include <complex>
#include <iostream>
#include <SFML/Graphics.hpp>

double map(double x, double from, double to, double from2, double to2) {
	return (x - from) / (to - from) * (to2 - from2) + from2;
}

// hue: 0-360°; sat: 0.f-1.f; val: 0.f-1.f
sf::Color hsv(int hue, float sat, float val)
{
	hue %= 360;
	while (hue < 0) hue += 360;

	if (sat < 0.f) sat = 0.f;
	if (sat > 1.f) sat = 1.f;

	if (val < 0.f) val = 0.f;
	if (val > 1.f) val = 1.f;

	int h = hue / 60;
	float f = float(hue) / 60 - h;
	float p = val * (1.f - sat);
	float q = val * (1.f - sat * f);
	float t = val * (1.f - sat * (1 - f));

	switch (h)
	{
	default:
	case 0:
	case 6: return sf::Color(val * 255, t * 255, p * 255);
	case 1: return sf::Color(q * 255, val * 255, p * 255);
	case 2: return sf::Color(p * 255, val * 255, t * 255);
	case 3: return sf::Color(p * 255, q * 255, val * 255);
	case 4: return sf::Color(t * 255, p * 255, val * 255);
	case 5: return sf::Color(val * 255, p * 255, q * 255);
	}
}

sf::Color mandelbrot(std::complex<double> c, int pre = 1000) {
	std::complex<double> z(0, 0);
	for (int i = 0; i < pre; ++i) {
		if (std::abs(z) >= 2) {
			return hsv(map((300 - i) % 600, 0, 360, 0, 360),
				1,
				map(i % 1000, 0, 1000, 0.8, 1));
		}
		z = z * z + c;
	}
	return sf::Color(0, 0, 0);
}

int main()
{
	int pres = 100;

	const unsigned int W = 1920;
	const unsigned int H = 1080; // you can change this to full window size later

	int iter = 1;

	sf::Texture t;
	std::string save = ("pic/set" + std::to_string(iter) + ".png");

	while (t.loadFromFile(save)) {
		save = ("pic/set" + std::to_string(iter) + ".png");
		iter++;
	}

	iter--;

	double left = -2, right = 1, top = 1, bot = -1;
	double	centerx = 0.360240443437614363236125244449545308482607807958585750488375814740195346059218100311752936722773426396233731729724987737320035372683285317664532401218521579554288661726564324134702299962817029213329980895208036363104546639698106204384566555001322985619004717862781192694046362748742863016467354574422779443226982622356594130430232458472420816652623492974891730419252651127672782407292315574480207005828774566475024380960675386215814315654794021855269375824443853463117354448779647099224311848192893972572398662626725254769950976527431277402440752868498588785436705371093442460696090720654908973712759963732914849861213100695402602927267843779747314419332179148608587129105289166676461292845685734536033692577618496925170576714796693411776794742904333484665301628662532967079174729170714156810530598764525260869731233845987202037712637770582084286587072766838497865108477149114659838883818795374195150936369987302574377608649625020864292915913378927790344097552591919409137354459097560040374880346637533711271919419723135538377394364882968994646845930838049998854075817859391340445151448381853615103761584177161812057928,
		centery = -0.6413130610648031748603750151793020665794949522823052595561775430644485741727536902556370230689681162370740565537072149790106973211105273740851993394803287437606238596262287731075999483940467161288840614581091294325709988992269165007394305732683208318834672366947550710920088501655704252385244481168836426277052232593412981472237968353661477793530336607247738951625817755401065045362273039788332245567345061665756708689359294516668271440525273653083717877701237756144214394870245598590883973716531691124286669552803640414068523325276808909040317617092683826521501539932397262012011082098721944643118695001226048977430038509470101715555439047884752058334804891389685530946112621573416582482926221804767466258346014417934356149837352092608891639072745930639364693513216719114523328990690069588676087923656657656023794484324797546024248328156586471662631008741349069961493817600100133439721557969263221185095951241491408756751582471307537382827924073746760884081704887902040036056611401378785952452105099242499241003208013460878442953408648178692353788153787229940221611731034405203519945313911627314900851851072122990492499999999999999999991,
		width = 5;

	for (int j = 1; j < iter; ++j) {
		width *= 0.975;
		pres += 1;
	}

	sf::Clock clock; // starts the clock

	while (true) {

		std::cout << "Rendering iteration #" << iter << std::endl;
		std::cout << "Zoom level is: " << width << std::endl;

		left = centerx - width / 2;
		right = centerx + width / 2;
		top = centery - width / 2;
		bot = centery + width / 2;

		sf::Uint8* pixels = new sf::Uint8[W*H * 4];

		sf::Texture texture;
		texture.create(W, H);

		for (register int i = 0; i < W*H * 4; i += 4) {

			int a = (i / 4) % W, b = (i / 4) / W;
			double x = map(a, 0, W, left, right);
			double y = map(b, 0, H, top, bot);

			std::complex<double> z(x, y);
			sf::Color col = mandelbrot(z, pres);

			pixels[i] = col.r;
			pixels[i + 1] = col.g;
			pixels[i + 2] = col.b;
			pixels[i + 3] = col.a;
		}

		texture.update(pixels);

		std::string save = ("pic/set" + std::to_string(iter) + ".png");

		texture.copyToImage().saveToFile(save);
		iter++;
		width *= 0.975;
		pres += 1;

		sf::Time elapsed = clock.getElapsedTime();
		std::cout << "It took " << elapsed.asSeconds() << " seconds to render." << std::endl << std::endl;
		clock.restart();

	}

	return 0;
}